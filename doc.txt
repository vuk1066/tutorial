/* When one component renders another component, 
this is what React refers to as the owner-ownee relationship, 
where the parent component is also called a composite component */

/* Refs are a way to reference an instance of 
a component from within our React application.
Refs don't work work with stateless function components*/

import ReactDOM from 'react-dom';
-> enables you to reach out to the DOM

 use -> this.props.children to acces innerHTML or nested components of another component

Shader -> small program written in a C like language called Open GLShaderLanguage -> GLSL
Props -> meant to be passed into our components as static values or methods
State -> is a collection of values that's meant to be managed by our components itself
Class component v. Stateless function -> a class can have state
Refs don't work with stateless function components. (=> use class)

{return (<h1> Hello </h1>);} -> jsx
{return React.createElement('h1',null,'Hello')} -> js

mounting and unmounting the component -> when a component is added or removed from the DOM

When we want to access the innerHTML or nested components of another component, we can use this.props.children in React. This is very similar to Angular 1's transclusion or Ember's yield or Web Component's content.

componentWillMount()
componentDidMount()
componentWillUnmount()
componentWillReceiveProps()
shouldComponentUpdate() => does not prevent state change only prevents re-rendering
componentDidUpdate()

///explaining *super()*  JS6
Calling super() is necessary only if you need to have a constructor.You don't have to call super() for every react component you create. However, if there is a constructor in your code, then you MUST call super:

class MyClass extends React.component {
    render(){
        return <div>Hello { this.props.world }</div>;
    }
}

class MyClass extends React.component{
    constructor(props){
        super();
        console.log(this.props); // this.props is undefined

    }
}

Call super(props) only if you want to access this.props inside the constructor. React automatically set it for you if you want to access it anywhere else.

/////

The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.
/////

Arrow functions are always anonymous. These function expressions are best suited for non-method functions and they can not be used as constructors.

*Basic syntax:
	(param1, param2, …, paramN) => { statements }
	(param1, param2, …, paramN) => expression
	// equivalent to: (param1, param2, …, paramN) => { return expression; }

	// Parentheses are optional when there's only one parameter:
	(singleParam) => { statements }
	singleParam => { statements }

	// A function with no parameters requires parentheses:
	() => { statements }
	() => expression // equivalent to: () => { return expression; }

*Advanced Syntax

// Parenthesize the body to return an object literal expression:
params => ({foo: bar})

// Rest parameters and default parameters are supported
(param1, param2, ...rest) => { statements }
(param1 = defaultValue1, param2, …, paramN = defaultValueN) => { statements }

// Destructuring within the parameter list is also supported
var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) => a + b + c;
f();  // 6

//////
The includes() method determines whether one string may be found within another string, returning true or false as appropriate.
*syntax:
str.includes(searchString[, position])
The position in this string at which to begin searching for searchString; defaults to 0

